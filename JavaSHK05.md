# day_12

## object类

1. 如果我们没有显式地声明一个类的父类的话，则此类继承与```java.lang.Object```类
2. 所有的Java类（除了```java.lang.Object``` 类之外都直接或间接的继承与```java.lang.Object``` 类
3. 意味着，所有的Java类具有```java.lang.Object```类声明的功能

## debug 操作

> 这个是要看英文的

| 英文       | 释义                     |
| ---------- | ------------------------ |
| Resume     | 执行到下一个断点         |
| Terminate  | 强制终止程序             |
| Stepinto   | 让你看到程序执行的每一步 |
| Stepover   | 执行一行程序             |
| Stepreturn | "跳出"Stepinto           |



## 方法的重写(override/overwrite)

1. 重写的规定：

```
方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{
//方法体
}
```

> 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法

+ 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
+ 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符

特殊情况：子类不能重写父类中声明为private权限的方法

+ 返回值类型：
  父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void

  父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类

  父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)

+ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型

2. 重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作

3. 应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。

## super关键字的使用

1. super理解为：父类的

2. super可以用来调用：属性、方法、构造器

3. super的使用：调用属性和方法

+ 我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."
+ 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用"super.属性"的方式，表明调用的是父类中声明的属性。
+ 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显的使用"super.方法"的方式，表明调用的是父类中被重写的方法。



4. super调用构造器

+ 我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器

+ "super(形参列表)"的使用，必须声明在子类构造器的首行！
+ 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现

+ 在构造器的首行，没有显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构器：super()

+ 在类的多个构造器中，至少有一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器

## 子类对象实例化的全过程

1. 从结果上来看：（继承性）
   + 子类继承父类以后，就获取了父类中声明的属性或方法。
   + 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。

2. 从过程上来看：
   + 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...
   + 直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。

> 虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。

> 编译看左，运行看右，new谁用谁

## 多态性

1. 多态性：可以理解为一个事物的多种形态。

2. 何为多态性：

   ​	对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）

3. 多态的使用：虚拟方法调用

   有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写类的方法。

   总结：编译，看左边；运行，看右边。

4. 多态性的使用前提：  ① 类的继承关系  ② 方法的重写

5. 对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）

> 重写   -----    晚绑定    ----    多态